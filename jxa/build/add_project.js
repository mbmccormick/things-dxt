// JXA script for add_project
// Generated by esbuild from modular sources
// DO NOT EDIT - this file is auto-generated

var JXAScript = (() => {
  // jxa/src/utils.js
  function parseLocalDate(dateString) {
    if (!dateString) return null;
    const [year, month, day] = dateString.split("-").map(Number);
    return new Date(year, month - 1, day, 0, 0, 0, 0);
  }
  function getDate(item, method) {
    try {
      const date = item[method]();
      if (!date) return null;
      return date.toISOString();
    } catch (e) {
      return null;
    }
  }
  function scheduleItem(things, item, dateString) {
    if (!dateString) return;
    try {
      const date = parseLocalDate(dateString);
      if (date) {
        things.schedule(item, { for: date });
      }
    } catch (e) {
    }
  }
  function formatTags(tags) {
    if (!tags || !Array.isArray(tags) || tags.length === 0) {
      return "";
    }
    return tags.join(", ");
  }
  function parseTags(tagString) {
    if (!tagString || typeof tagString !== "string") {
      return [];
    }
    return tagString.split(",").map((t) => t.trim()).filter((t) => t);
  }
  function mapTodo(todo) {
    const result = {
      id: todo.id(),
      name: todo.name(),
      status: todo.status(),
      notes: todo.notes() || "",
      tagNames: todo.tagNames() || "",
      // Return as string per SDEF
      tags: parseTags(todo.tagNames()),
      // Also return as array for convenience
      deadline: getDate(todo, "dueDate"),
      // User-friendly: when actually due
      when: getDate(todo, "activationDate"),
      // User-friendly: when scheduled to work on
      creationDate: getDate(todo, "creationDate"),
      modificationDate: getDate(todo, "modificationDate"),
      completionDate: getDate(todo, "completionDate"),
      cancellationDate: getDate(todo, "cancellationDate")
    };
    try {
      const project = todo.project();
      if (project) {
        result.project = {
          id: project.id(),
          name: project.name()
        };
      }
    } catch (e) {
      result.project = null;
    }
    try {
      const area = todo.area();
      if (area) {
        result.area = {
          id: area.id(),
          name: area.name()
        };
      }
    } catch (e) {
      result.area = null;
    }
    try {
      const checklistItems = todo.checklistItems();
      if (checklistItems && checklistItems.length > 0) {
        result.checklistItems = checklistItems.map((item) => ({
          name: item.name(),
          completed: item.completed()
        }));
      }
    } catch (e) {
      result.checklistItems = [];
    }
    return result;
  }
  function mapProject(project) {
    const result = {
      id: project.id(),
      name: project.name(),
      status: project.status(),
      notes: project.notes() || "",
      tagNames: project.tagNames() || "",
      // Return as string per SDEF
      tags: parseTags(project.tagNames()),
      // Also return as array for convenience
      deadline: getDate(project, "dueDate"),
      // User-friendly: when actually due
      when: getDate(project, "activationDate"),
      // User-friendly: when scheduled to work on
      creationDate: getDate(project, "creationDate"),
      modificationDate: getDate(project, "modificationDate"),
      completionDate: getDate(project, "completionDate"),
      cancellationDate: getDate(project, "cancellationDate")
    };
    try {
      const area = project.area();
      if (area) {
        result.area = {
          id: area.id(),
          name: area.name()
        };
      }
    } catch (e) {
      result.area = null;
    }
    return result;
  }
  function mapArea(area) {
    return {
      id: area.id(),
      name: area.name(),
      tagNames: area.tagNames() || "",
      // Return as string per SDEF
      tags: parseTags(area.tagNames()),
      // Also return as array for convenience
      collapsed: area.collapsed()
    };
  }
  function safeGetList(things, listId) {
    try {
      return things.lists.byId(listId).toDos();
    } catch (e) {
      return [];
    }
  }
  var LIST_IDS = {
    INBOX: "TMInboxListSource",
    TODAY: "TMTodayListSource",
    UPCOMING: "TMCalendarListSource",
    ANYTIME: "TMNextListSource",
    SOMEDAY: "TMSomedayListSource",
    LOGBOOK: "TMLogbookListSource",
    TRASH: "TMTrashListSource"
  };

  // jxa/src/todos.js
  var TodoOperations = class {
    /**
     * Add a new todo
     */
    static add(things, params) {
      const todoProps = {
        name: params.name
      };
      if (params.notes) {
        todoProps.notes = params.notes;
      }
      const todo = things.ToDo(todoProps);
      things.toDos.push(todo);
      if (params.tags && params.tags.length > 0) {
        todo.tagNames = formatTags(params.tags);
      }
      if (params.checklist_items && params.checklist_items.length > 0) {
        params.checklist_items.forEach((itemName) => {
          const checklistItem = things.ChecklistItem({ name: itemName });
          todo.checklistItems.push(checklistItem);
        });
      }
      if (params.activation_date) {
        scheduleItem(things, todo, params.activation_date);
      }
      if (params.due_date) {
        todo.dueDate = parseLocalDate(params.due_date);
      }
      if (params.list_id) {
        try {
          const list = things.lists.byId(params.list_id);
          list.toDos.push(todo);
        } catch (e) {
        }
      } else if (params.list_title) {
        let targetList;
        try {
          const projects = things.projects();
          for (let project of projects) {
            if (project.name() === params.list_title) {
              targetList = project;
              break;
            }
          }
        } catch (e) {
        }
        if (!targetList) {
          try {
            const areas = things.areas();
            for (let area of areas) {
              if (area.name() === params.list_title) {
                targetList = area;
                break;
              }
            }
          } catch (e) {
          }
        }
        if (targetList) {
          targetList.toDos.push(todo);
        }
      }
      if (params.heading && params.list_id) {
        try {
          const project = things.projects.byId(params.list_id);
          const todos = project.toDos();
          const headings = todos.filter((t) => t.name() === params.heading);
          if (headings.length > 0) {
            const heading = headings[0];
            const headingIndex = todos.indexOf(heading);
            things.move(todo, { to: project.toDos[headingIndex] });
          }
        } catch (e) {
        }
      }
      return mapTodo(todo);
    }
    /**
     * Update an existing todo
     */
    static update(things, params) {
      const todo = things.toDos.byId(params.id);
      if (params.name !== void 0) {
        todo.name = params.name;
      }
      if (params.notes !== void 0) {
        todo.notes = params.notes;
      }
      if (params.tags !== void 0) {
        todo.tagNames = formatTags(params.tags);
      }
      if (params.completed === true) {
        todo.status = "completed";
      } else if (params.canceled === true) {
        todo.status = "canceled";
      }
      if (params.activation_date !== void 0) {
        if (params.activation_date) {
          scheduleItem(things, todo, params.activation_date);
        } else {
          try {
            scheduleItem(things, todo, "2099-12-31");
            things.schedule(todo, { for: null });
          } catch (e) {
          }
        }
      }
      if (params.due_date !== void 0) {
        todo.dueDate = params.due_date ? parseLocalDate(params.due_date) : null;
      }
      if (params.checklist_items !== void 0) {
        try {
          const existingItems = todo.checklistItems();
          existingItems.forEach((item) => {
            things.delete(item);
          });
        } catch (e) {
        }
        if (params.checklist_items.length > 0) {
          params.checklist_items.forEach((itemName) => {
            const checklistItem = things.ChecklistItem({ name: itemName });
            todo.checklistItems.push(checklistItem);
          });
        }
      }
      return mapTodo(todo);
    }
    /**
     * Get all todos, optionally filtered by project
     */
    static getAll(things, params) {
      let todos;
      if (params.project_uuid) {
        try {
          const project = things.projects.byId(params.project_uuid);
          todos = project.toDos();
        } catch (e) {
          return [];
        }
      } else {
        todos = things.toDos();
      }
      const includeItems = params.include_items !== false;
      if (includeItems) {
        return todos.map(mapTodo);
      } else {
        return todos.map((todo) => ({
          id: todo.id(),
          name: todo.name(),
          status: todo.status()
        }));
      }
    }
  };

  // jxa/src/projects.js
  var ProjectOperations = class {
    /**
     * Add a new project
     */
    static add(things, params) {
      const projectProps = {
        name: params.name
      };
      if (params.notes) {
        projectProps.notes = params.notes;
      }
      const project = things.Project(projectProps);
      things.projects.push(project);
      if (params.tags && params.tags.length > 0) {
        project.tagNames = formatTags(params.tags);
      }
      if (params.activation_date) {
        scheduleItem(things, project, params.activation_date);
      }
      if (params.due_date) {
        project.dueDate = parseLocalDate(params.due_date);
      }
      if (params.area_id) {
        try {
          const area = things.areas.byId(params.area_id);
          project.area = area;
        } catch (e) {
        }
      } else if (params.area_title) {
        try {
          const areas = things.areas();
          for (let area of areas) {
            if (area.name() === params.area_title) {
              project.area = area;
              break;
            }
          }
        } catch (e) {
        }
      }
      if (params.todos && params.todos.length > 0) {
        params.todos.forEach((todoTitle) => {
          const todo = things.ToDo({ name: todoTitle });
          project.toDos.push(todo);
        });
      }
      return mapProject(project);
    }
    /**
     * Update an existing project
     */
    static update(things, params) {
      const project = things.projects.byId(params.id);
      if (params.name !== void 0) {
        project.name = params.name;
      }
      if (params.notes !== void 0) {
        project.notes = params.notes;
      }
      if (params.tags !== void 0) {
        project.tagNames = formatTags(params.tags);
      }
      if (params.completed === true) {
        project.status = "completed";
      } else if (params.canceled === true) {
        project.status = "canceled";
      }
      if (params.activation_date !== void 0) {
        if (params.activation_date) {
          scheduleItem(things, project, params.activation_date);
        } else {
          try {
            scheduleItem(things, project, "2099-12-31");
            things.schedule(project, { for: null });
          } catch (e) {
          }
        }
      }
      if (params.due_date !== void 0) {
        project.dueDate = params.due_date ? parseLocalDate(params.due_date) : null;
      }
      return mapProject(project);
    }
    /**
     * Get all projects
     */
    static getAll(things, params) {
      const projects = things.projects();
      const includeItems = params.include_items || false;
      return projects.map((project) => {
        const mapped = mapProject(project);
        if (includeItems) {
          try {
            mapped.todos = project.toDos().map(mapTodo);
          } catch (e) {
            mapped.todos = [];
          }
        }
        return mapped;
      });
    }
  };

  // jxa/src/lists.js
  var ListOperations = class {
    /**
     * Get inbox todos
     */
    static getInbox(things, params) {
      const inbox = safeGetList(things, LIST_IDS.INBOX);
      return inbox.map(mapTodo);
    }
    /**
     * Get today todos
     */
    static getToday(things, params) {
      const today = safeGetList(things, LIST_IDS.TODAY);
      return today.map(mapTodo);
    }
    /**
     * Get upcoming todos
     */
    static getUpcoming(things, params) {
      const upcoming = safeGetList(things, LIST_IDS.UPCOMING);
      return upcoming.map(mapTodo);
    }
    /**
     * Get anytime todos
     */
    static getAnytime(things, params) {
      const anytime = safeGetList(things, LIST_IDS.ANYTIME);
      return anytime.map(mapTodo);
    }
    /**
     * Get someday todos
     */
    static getSomeday(things, params) {
      const someday = safeGetList(things, LIST_IDS.SOMEDAY);
      return someday.map(mapTodo);
    }
    /**
     * Get logbook (completed items)
     */
    static getLogbook(things, params) {
      const logbook = safeGetList(things, LIST_IDS.LOGBOOK);
      let filtered = logbook;
      if (params.period) {
        const match = params.period.match(/^(\d+)([dwmy])$/);
        if (match) {
          const amount = parseInt(match[1]);
          const unit = match[2];
          const cutoffDate = /* @__PURE__ */ new Date();
          switch (unit) {
            case "d":
              cutoffDate.setDate(cutoffDate.getDate() - amount);
              break;
            case "w":
              cutoffDate.setDate(cutoffDate.getDate() - amount * 7);
              break;
            case "m":
              cutoffDate.setMonth(cutoffDate.getMonth() - amount);
              break;
            case "y":
              cutoffDate.setFullYear(cutoffDate.getFullYear() - amount);
              break;
          }
          filtered = logbook.filter((todo) => {
            try {
              const completionDate = todo.completionDate();
              return completionDate && completionDate >= cutoffDate;
            } catch (e) {
              return false;
            }
          });
        }
      }
      const limit = params.limit || 100;
      const limited = filtered.slice(0, limit);
      return limited.map(mapTodo);
    }
    /**
     * Get trash
     */
    static getTrash(things, params) {
      const trash = safeGetList(things, LIST_IDS.TRASH);
      return trash.map(mapTodo);
    }
  };

  // jxa/src/search.js
  var SearchOperations = class {
    /**
     * Search todos by query
     */
    static searchTodos(things, params) {
      const query = params.query.toLowerCase();
      const allTodos = things.toDos();
      const matches = allTodos.filter((todo) => {
        try {
          const name = todo.name().toLowerCase();
          const notes = (todo.notes() || "").toLowerCase();
          return name.includes(query) || notes.includes(query);
        } catch (e) {
          return false;
        }
      });
      return matches.map(mapTodo);
    }
    /**
     * Search all items (todos, projects, areas)
     */
    static searchItems(things, params) {
      const query = params.query.toLowerCase();
      const results = [];
      try {
        const todos = things.toDos();
        todos.forEach((todo) => {
          try {
            const name = todo.name().toLowerCase();
            const notes = (todo.notes() || "").toLowerCase();
            if (name.includes(query) || notes.includes(query)) {
              results.push({
                type: "todo",
                ...mapTodo(todo)
              });
            }
          } catch (e) {
          }
        });
      } catch (e) {
      }
      try {
        const projects = things.projects();
        projects.forEach((project) => {
          try {
            const name = project.name().toLowerCase();
            const notes = (project.notes() || "").toLowerCase();
            if (name.includes(query) || notes.includes(query)) {
              results.push({
                type: "project",
                ...mapProject(project)
              });
            }
          } catch (e) {
          }
        });
      } catch (e) {
      }
      try {
        const areas = things.areas();
        areas.forEach((area) => {
          try {
            const name = area.name().toLowerCase();
            if (name.includes(query)) {
              results.push({
                type: "area",
                ...mapArea(area)
              });
            }
          } catch (e) {
          }
        });
      } catch (e) {
      }
      return results;
    }
    /**
     * Advanced search with multiple criteria
     */
    static searchAdvanced(things, params) {
      const query = params.query.toLowerCase();
      let todos = [];
      try {
        todos = Array.from(things.toDos());
      } catch (e) {
        return [];
      }
      if (params.completed) {
        try {
          const logbook = things.lists.byId(LIST_IDS.LOGBOOK).toDos();
          todos = todos.concat(Array.from(logbook));
        } catch (e) {
        }
      }
      if (params.canceled) {
        try {
          const allTodos = things.toDos();
          const canceled = allTodos.filter((t) => {
            try {
              return t.status() === "canceled";
            } catch (e) {
              return false;
            }
          });
          todos = todos.concat(canceled);
        } catch (e) {
        }
      }
      if (params.trashed) {
        try {
          const trash = things.lists.byId(LIST_IDS.TRASH).toDos();
          todos = todos.concat(Array.from(trash));
        } catch (e) {
        }
      }
      let matches = todos.filter((todo) => {
        try {
          const name = todo.name().toLowerCase();
          const notes = (todo.notes() || "").toLowerCase();
          return name.includes(query) || notes.includes(query);
        } catch (e) {
          return false;
        }
      });
      if (params.tags && params.tags.length > 0) {
        matches = matches.filter((todo) => {
          try {
            const tagNames = todo.tagNames() || "";
            const todoTags = parseTags(tagNames);
            return params.tags.some((tag) => todoTags.includes(tag));
          } catch (e) {
            return false;
          }
        });
      }
      return matches.map(mapTodo);
    }
    /**
     * Get recent items
     */
    static getRecent(things, params) {
      const days = params.days || 7;
      const cutoffDate = /* @__PURE__ */ new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      let allTodos;
      try {
        allTodos = things.toDos();
      } catch (e) {
        return [];
      }
      const recent = allTodos.filter((todo) => {
        try {
          const modDate = todo.modificationDate();
          return modDate && modDate >= cutoffDate;
        } catch (e) {
          return false;
        }
      });
      recent.sort((a, b) => {
        try {
          const dateA = a.modificationDate();
          const dateB = b.modificationDate();
          return dateB - dateA;
        } catch (e) {
          return 0;
        }
      });
      return recent.map(mapTodo);
    }
    /**
     * Show single item details
     */
    static showItem(things, params) {
      const id = params.id;
      try {
        const item = things.toDos.byId(id);
        return {
          type: "todo",
          ...mapTodo(item)
        };
      } catch (e) {
      }
      try {
        const item = things.projects.byId(id);
        return {
          type: "project",
          ...mapProject(item)
        };
      } catch (e) {
      }
      try {
        const item = things.areas.byId(id);
        return {
          type: "area",
          ...mapArea(item)
        };
      } catch (e) {
      }
      throw new Error(`Item not found with id: ${id}`);
    }
  };

  // jxa/src/tags.js
  var TagOperations = class {
    /**
     * Get all tags
     */
    static getAll(things, params) {
      try {
        const tags = things.tags();
        return tags.map((tag) => tag.name());
      } catch (e) {
        return [];
      }
    }
    /**
     * Get items with a specific tag
     */
    static getTaggedItems(things, params) {
      const tagName = params.tag_title;
      let allTodos;
      try {
        allTodos = things.toDos();
      } catch (e) {
        return [];
      }
      const tagged = allTodos.filter((todo) => {
        try {
          const tagNames = todo.tagNames() || "";
          const tags = parseTags(tagNames);
          return tags.includes(tagName);
        } catch (e) {
          return false;
        }
      });
      return tagged.map(mapTodo);
    }
  };

  // jxa/src/areas.js
  var AreaOperations = class {
    /**
     * Get all areas
     */
    static getAll(things, params) {
      let areas;
      try {
        areas = things.areas();
      } catch (e) {
        return [];
      }
      const includeItems = params.include_items || false;
      return areas.map((area) => {
        const mapped = mapArea(area);
        if (includeItems) {
          try {
            mapped.todos = area.toDos().map(mapTodo);
          } catch (e) {
            mapped.todos = [];
          }
        }
        return mapped;
      });
    }
  };

  // jxa/src/main.js
  function run(argv) {
    try {
      const params = JSON.parse(argv[0] || "{}");
      const operation = params.operation || "unknown";
      const things = Application("com.culturedcode.ThingsMac");
      things.includeStandardAdditions = false;
      let result;
      switch (operation) {
        // Todo operations
        case "add_todo":
          result = TodoOperations.add(things, params);
          break;
        case "update_todo":
          result = TodoOperations.update(things, params);
          break;
        case "get_todos":
          result = TodoOperations.getAll(things, params);
          break;
        // Project operations
        case "add_project":
          result = ProjectOperations.add(things, params);
          break;
        case "update_project":
          result = ProjectOperations.update(things, params);
          break;
        case "get_projects":
          result = ProjectOperations.getAll(things, params);
          break;
        // List operations (inbox, today, etc.)
        case "get_inbox":
          result = ListOperations.getInbox(things, params);
          break;
        case "get_today":
          result = ListOperations.getToday(things, params);
          break;
        case "get_upcoming":
          result = ListOperations.getUpcoming(things, params);
          break;
        case "get_anytime":
          result = ListOperations.getAnytime(things, params);
          break;
        case "get_someday":
          result = ListOperations.getSomeday(things, params);
          break;
        case "get_logbook":
          result = ListOperations.getLogbook(things, params);
          break;
        case "get_trash":
          result = ListOperations.getTrash(things, params);
          break;
        // Search operations
        case "search_todos":
          result = SearchOperations.searchTodos(things, params);
          break;
        case "search_items":
          result = SearchOperations.searchItems(things, params);
          break;
        case "search_advanced":
          result = SearchOperations.searchAdvanced(things, params);
          break;
        case "get_recent":
          result = SearchOperations.getRecent(things, params);
          break;
        case "show_item":
          result = SearchOperations.showItem(things, params);
          break;
        // Tag operations
        case "get_tags":
          result = TagOperations.getAll(things, params);
          break;
        case "get_tagged_items":
          result = TagOperations.getTaggedItems(things, params);
          break;
        // Area operations
        case "get_areas":
          result = AreaOperations.getAll(things, params);
          break;
        default:
          throw new Error(`Unknown operation: ${operation}`);
      }
      return JSON.stringify({
        success: true,
        data: result
      });
    } catch (error) {
      return JSON.stringify({
        success: false,
        error: {
          message: error.message || String(error),
          type: error.name || "Error",
          stack: error.stack
        }
      });
    }
  }

  // jxa/src/entry_add_project.js
  function jxaRun(argv) {
    const params = JSON.parse(argv[0] || "{}");
    params.operation = "add_project";
    return run([JSON.stringify(params)]);
  }
  if (typeof run !== "undefined") {
    globalThis.run = jxaRun;
  }
})();


// JXA entry point
function run(argv) {
  return jxaRun(argv);
}
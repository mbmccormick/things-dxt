#!/usr/bin/env node

/**
 * Build script for JXA modules
 * Improved with better error handling and validation
 */

import { build } from 'esbuild';
import { promises as fs } from 'fs';
import path from 'path';

const SRC_DIR = 'jxa/src';
const BUILD_DIR = 'jxa/build';

// Operation definitions
const OPERATIONS = [
  'add_todo', 'update_todo', 'get_todos',
  'add_project', 'update_project', 'get_projects',
  'get_inbox', 'get_today', 'get_upcoming', 'get_anytime', 'get_someday',
  'get_logbook', 'get_trash', 'search_todos', 'search_items', 'search_advanced',
  'get_recent', 'show_item', 'get_tags', 'get_tagged_items', 'get_areas'
];

// Build configuration optimized for JXA
const BUILD_CONFIG = {
  bundle: true,
  platform: 'neutral',
  target: 'es2020',
  format: 'iife',
  globalName: 'JXAScript',
  minify: false,
  sourcemap: false,
  write: false,
  logLevel: 'warning'
};

async function ensureDirectories() {
  try {
    await fs.mkdir(BUILD_DIR, { recursive: true });
  } catch (error) {
    console.error(`❌ Failed to create build directory: ${error.message}`);
    process.exit(1);
  }
}

async function validateSourceFiles() {
  const requiredFiles = ['main.js', 'utils.js', 'todos.js', 'projects.js', 'lists.js', 'search.js', 'tags.js', 'areas.js'];
  
  for (const file of requiredFiles) {
    try {
      await fs.access(path.join(SRC_DIR, file));
    } catch (error) {
      console.error(`❌ Required source file missing: ${file}`);
      process.exit(1);
    }
  }
}

async function buildOperation(operation) {
  const entryContent = `
import { run } from './main.js';

function jxaRun(argv) {
  const params = JSON.parse(argv[0] || '{}');
  params.operation = '${operation}';
  return run([JSON.stringify(params)]);
}

if (typeof run !== 'undefined') {
  globalThis.run = jxaRun;
}
`;

  const entryPath = path.join(SRC_DIR, `entry_${operation}.js`);
  
  try {
    // Write temporary entry file
    await fs.writeFile(entryPath, entryContent);

    // Build the bundle
    const result = await build({
      ...BUILD_CONFIG,
      entryPoints: [entryPath],
    });

    if (result.errors.length > 0) {
      throw new Error(`Build errors: ${result.errors.map(e => e.text).join(', ')}`);
    }

    // Get the bundled content
    const bundledContent = result.outputFiles[0].text;
    
    // Create JXA-compatible wrapper
    const jxaScript = `// JXA script for ${operation}
// Generated by esbuild from modular sources
// DO NOT EDIT - this file is auto-generated

${bundledContent}

// JXA entry point
function run(argv) {
  return jxaRun(argv);
}`;

    // Write the final script
    const outputPath = path.join(BUILD_DIR, `${operation}.js`);
    await fs.writeFile(outputPath, jxaScript);
    
    console.log(`✅ Built ${operation}.js`);
    return true;
    
  } catch (error) {
    console.error(`❌ Failed to build ${operation}: ${error.message}`);
    return false;
  } finally {
    // Clean up temporary entry file
    try {
      await fs.unlink(entryPath);
    } catch (e) {
      // Ignore cleanup errors
    }
  }
}

async function main() {
  console.log('🔨 Building JXA scripts...');
  console.log(`📂 Source: ${SRC_DIR}`);
  console.log(`📁 Output: ${BUILD_DIR}`);
  
  // Setup
  await ensureDirectories();
  await validateSourceFiles();
  
  // Build all operations
  let successful = 0;
  let failed = 0;
  
  for (const operation of OPERATIONS) {
    const success = await buildOperation(operation);
    if (success) {
      successful++;
    } else {
      failed++;
    }
  }
  
  // Report results
  console.log('\n' + '='.repeat(50));
  console.log(`📊 Build Results: ${successful} successful, ${failed} failed`);
  
  if (failed > 0) {
    console.error(`❌ Build completed with ${failed} failures`);
    process.exit(1);
  } else {
    console.log('✨ All JXA scripts built successfully!');
    console.log(`📁 Output directory: ${BUILD_DIR}`);
  }
}

// Handle errors gracefully
process.on('uncaughtException', (error) => {
  console.error('❌ Uncaught exception during build:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  console.error('❌ Unhandled rejection during build:', reason);
  process.exit(1);
});

main().catch((error) => {
  console.error('❌ Build script failed:', error.message);
  process.exit(1);
});